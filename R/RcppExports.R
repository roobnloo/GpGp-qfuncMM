# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Multiply approximate inverse Cholesky by a vector
#'
#' Vecchia's approximation implies a sparse approximation to the
#' inverse Cholesky factor of the covariance matrix. This function
#' returns the result of multiplying that matrix by a vector.
#' @param Linv Entries of the sparse inverse Cholesky factor,
#' usually the output from \code{\link{vecchia_Linv}}.
#' @param z the vector to be multiplied
#' @inheritParams vecchia_meanzero_loglik
#' @return the product of the sparse inverse Cholesky factor with a vector
#' @noRd
Linv_mult <- function(Linv, z, NNarray) {
    .Call('_GpGpQFuncMM_Linv_mult', PACKAGE = 'GpGpQFuncMM', Linv, z, NNarray)
}

#' Multiply approximate Cholesky by a vector
#'
#' Vecchia's approximation implies a sparse approximation to the
#' inverse Cholesky factor of the covariance matrix. This function
#' returns the result of multiplying the inverse of that matrix by a vector
#' (i.e. an approximation to the Cholesky factor).
#' @param Linv Entries of the sparse inverse Cholesky factor,
#' usually the output from \code{\link{vecchia_Linv}}.
#' @param z the vector to be multiplied
#' @inheritParams vecchia_meanzero_loglik
#' @return the product of the Cholesky factor with a vector
#' @noRd
L_mult <- function(Linv, z, NNarray) {
    .Call('_GpGpQFuncMM_L_mult', PACKAGE = 'GpGpQFuncMM', Linv, z, NNarray)
}

#' Multiply transpose of approximate inverse Cholesky by a vector
#'
#' Vecchia's approximation implies a sparse approximation to the
#' inverse Cholesky factor of the covariance matrix. This function
#' returns the result of multiplying the transpose of that matrix by a vector.
#' @param Linv Entries of the sparse inverse Cholesky factor,
#' usually the output from \code{\link{vecchia_Linv}}.
#' @param z the vector to be multiplied
#' @inheritParams vecchia_meanzero_loglik
#' @return the product of the transpose of the
#' sparse inverse Cholesky factor with a vector
#' @noRd
Linv_t_mult <- function(Linv, z, NNarray) {
    .Call('_GpGpQFuncMM_Linv_t_mult', PACKAGE = 'GpGpQFuncMM', Linv, z, NNarray)
}

#' Multiply transpose of approximate Cholesky by a vector
#'
#' Vecchia's approximation implies a sparse approximation to the
#' inverse Cholesky factor of the covariance matrix. This function
#' returns the result of multiplying the transpose of the
#' inverse of that matrix by a vector
#' (i.e. an approximation to the transpose of the Cholesky factor).
#' @param Linv Entries of the sparse inverse Cholesky factor,
#' usually the output from \code{\link{vecchia_Linv}}.
#' @param z the vector to be multiplied
#' @inheritParams vecchia_meanzero_loglik
#' @return the product of the transpose of the Cholesky factor with a vector
#' @noRd
L_t_mult <- function(Linv, z, NNarray) {
    .Call('_GpGpQFuncMM_L_t_mult', PACKAGE = 'GpGpQFuncMM', Linv, z, NNarray)
}

#' Entries of inverse Cholesky approximation
#'
#' This function returns the entries of the inverse Cholesky
#' factor of the covariance matrix implied by Vecchia's approximation.
#' For return matrix \code{Linv}, \code{Linv[i,]} contains
#' the non-zero entries of row \code{i} of
#' the inverse Cholesky matrix. The columns of the non-zero entries
#' are specified in \code{NNarray[i,]}.
#' @inheritParams vecchia_meanzero_loglik
#' @param start_ind Compute entries of Linv only for rows \code{start_ind}
#' until the last row.
#' @param additional_info A matrix of additional information that can be passed
#'   to the covariance function.
#' @return matrix containing entries of inverse Cholesky
#' @examples
#' n1 <- 40
#' n2 <- 40
#' n <- n1*n2
#' locs <- as.matrix( expand.grid( (1:n1)/n1, (1:n2)/n2 ) )
#' covparms <- c(2, 0.2, 0.75, 0)
#' NNarray <- find_ordered_nn(locs,20)
#' Linv <- vecchia_Linv(covparms, "matern_isotropic", locs, NNarray)
#' @noRd
vecchia_Linv <- function(covparms, covfun_name, locs, NNarray, start_ind = 1L, additional_info = NULL) {
    .Call('_GpGpQFuncMM_vecchia_Linv', PACKAGE = 'GpGpQFuncMM', covparms, covfun_name, locs, NNarray, start_ind, additional_info)
}

#' Compute QFunc Covariance Matrix.
#'
#' @param stage1_parms A 2 x 5 matrix of stage 1 paramerters.
#' @param covparms 5-vector of stage1 parameters.
#' @param locs A matrix with \code{n} rows and 5 columns.
test_qfunc_cov <- function(stage1_parms, covparms, locs) {
    .Call('_GpGpQFuncMM_test_qfunc_cov', PACKAGE = 'GpGpQFuncMM', stage1_parms, covparms, locs)
}

#' Compute Derivative of QFunc Covariance Matrix.
#'
#' @param stage1_parms A 2 x 5 matrix of stage 1 paramerters.
#' @param covparms 5-vector of stage1 parameters.
#' @param locs A matrix with \code{n} rows and 5 columns.
test_d_qfunc_cov <- function(stage1_parms, covparms, locs) {
    .Call('_GpGpQFuncMM_test_d_qfunc_cov', PACKAGE = 'GpGpQFuncMM', stage1_parms, covparms, locs)
}

vecchia_profbeta_loglik_grad_info <- function(covparms, covfun_name, y, X, locs, NNarray, additional_info = matrix()) {
    .Call('_GpGpQFuncMM_vecchia_profbeta_loglik_grad_info', PACKAGE = 'GpGpQFuncMM', covparms, covfun_name, y, X, locs, NNarray, additional_info)
}

vecchia_profbeta_loglik <- function(covparms, covfun_name, y, X, locs, NNarray) {
    .Call('_GpGpQFuncMM_vecchia_profbeta_loglik', PACKAGE = 'GpGpQFuncMM', covparms, covfun_name, y, X, locs, NNarray)
}

vecchia_grouped_profbeta_loglik_grad_info <- function(covparms, covfun_name, y, X, locs, NNlist, additional_info = matrix()) {
    .Call('_GpGpQFuncMM_vecchia_grouped_profbeta_loglik_grad_info', PACKAGE = 'GpGpQFuncMM', covparms, covfun_name, y, X, locs, NNlist, additional_info)
}

vecchia_grouped_profbeta_loglik <- function(covparms, covfun_name, y, X, locs, NNlist) {
    .Call('_GpGpQFuncMM_vecchia_grouped_profbeta_loglik', PACKAGE = 'GpGpQFuncMM', covparms, covfun_name, y, X, locs, NNlist)
}

vecchia_grouped_meanzero_loglik <- function(covparms, covfun_name, y, locs, NNlist) {
    .Call('_GpGpQFuncMM_vecchia_grouped_meanzero_loglik', PACKAGE = 'GpGpQFuncMM', covparms, covfun_name, y, locs, NNlist)
}

